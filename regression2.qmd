# Geradenmodelle 2




## Lernsteuerung




### Standort im Lernpfad

Abb. @fig-ueberblick zeigt den Standort dieses Kapitels im Lernpfad und gibt damit einen Ãœberblick Ã¼ber das Thema dieses Kapitels im Kontext aller Kapitel.







### Lernziele


- Sie kÃ¶nnen Regressionsmodelle fÃ¼r Forschungsfragen mit binÃ¤rer, nominaler und metrischer UV erlÃ¤utern und in R anwenden.
- Sie kÃ¶nnen Interaktionseffekte in Regressionsmodellen erlÃ¤utern und in R anwenden.
- Sie kÃ¶nnen den Anwendungszweck von Zentrieren und z-Transformationen zur besseren Interpretation von Regressionsmodellen erlÃ¤utern und in R anwenden.


### BenÃ¶tigte R-Pakete

```{r}
#| message: false
library(tidyverse)
library(easystats)
```


```{r}
#| include: false
library(ggpubr)
```


## Wetter in Deutschland


:::{#exm-wetterdaten}
### Wetterdaten
Nachdem Sie einige Zeit als Datenanalyst bei dem Online-Auktionshaus gearbeitet haben, stand Ihnen der Sinn nach ewtas Abwechslung. 
Viel Geld verdienen und Ruhm und Anerkennung sind ja schon ganz nett,
aber Ihnen viel ein, dass Sie ja zu Generation Z gehÃ¶ren, 
und daher den schnÃ¶den Mammon nicht so hoch schÃ¤tzen sollten.
Sie entschlieÃŸen sich, Ihre hochgeschÃ¤tzten Analyse-Skills fÃ¼r etwas einzusetzen,
das Ihnen sinnvoll erscheint: Die Analyse des Klimawandels.

Beim [Deutschen Wetterdienst, DWD](https://www.dwd.de/DE/Home/home_node.html) haben Sie sich Wetterdaten von Deutschland heruntergeladen.
Nach etwas [Datenjudo, auf das wir hier nicht eingehen wollen](https://data-se.netlify.app/2022/07/24/preparing-german-weather-data/) 
resultiert ein schÃ¶ner Datensatz, den Sie jetzt analysieren wollen:

```{r}
wetter_path <- "https://raw.githubusercontent.com/sebastiansauer/datasets/main/csv/precip_temp_DWD.csv"
wetter <- read.csv(wetter_path)
```

In @tbl-wetter kann man sich die Daten en Detail anschauen.

```{r}
#| tbl-cap: Wetterdaten fÃ¼r Deutschland
#| label: tbl-wetter
#| echo: false
wetter
```

Hervorragend!

An die Arbeit ğŸ’ª 

:::


### metrische UV

Sie stellen sich nun folgende Forschungsfrage:

>   ğŸ§‘â€ğŸ“ Um wieviel ist die Temperatur in Deutschland pro Jahr gestiegen, wenn man die letzten ca. 100 Jahre betrachtet?$


```{r}
lm_wetter1 <- lm(temp ~ year, data = wetter)
parameters(lm_wetter1)
```

Laut Ihrem Modell wurde es pro Jahr um 0.01 Grad wÃ¤rmer, pro Jahrzehnt also 0.1 und pro Jahrhundert 1 Grad.


>   ğŸ§‘â€ğŸ“ Das ist sicherlich nicht linear! Vermutlich ist die Temperatur bis 1950 konstant geblieben und jetzt knallt sie durch die Decke!

>   ğŸ‘¨â€ğŸ« Mit der Ruhe, schauen wir uns alles noch an.

Das Modell, bzw. die SchÃ¤tzungen zu den erwarteten Werten, kann mich sich so ausgeben lassen, s. @fig-wetter1, links.
Allerdings sind das zu viele Datenpunkte. Wir sollten es vielleicht anders visualisieren, s. fig-wetter1, rechts.
Dazu aggregieren wir die Messwerte eines Jahres zu jeweils einem Mittelwert.


```{r}
wetter_summ <-
  wetter %>% 
  group_by(year) %>% 
  summarise(temp = mean(temp))
```

Auf dieser Basis erstellen wir ein neues lineares Modell:

```{r}
lm_wetter1a <- lm(temp ~ year, data = wetter_summ)
parameters(lm_wetter1a)
```


```{r}
#| label: fig-wetter1
#| fig-cap: "Die VerÃ¤nderung der mittleren Temperatur in Deutschland im Zeitverlauf (Datenquelle: DWD)"
#| layout-ncol: 2
#| fig-subcap:
#|   - Jeder Punkt ist ein Tag
#|   - Jeder Punkt ist ein Jahr
plot(estimate_relation(lm_wetter1))
plot(estimate_relation(lm_wetter1a))
```


>    ğŸ§‘â€ğŸ“ Moment mal, der Achsenabschnitt liegt bei -15 Grad! Was soll das bitte bedeuten?


### UV zentrieren

Der Achsenabschnitt ist definiert als der Y-Wert an der Stelle X=0.
In den Wetterdaten wÃ¤re Jahr=0 Christi Geburt. 
Da unsere Wetteraufzeichnung gerade mal a. 150 Jahre in die Vergangenheit reicht,
ist es vollkommen vermessen, dass Modell 2000 Jahre in die Vergangenheit zu extraplieren,
ganz ohne dass wir dafÃ¼r Daten haben, s. @fig-extrapolation.


![Du sollst nicht ein Modell weit auÃŸerhalb seines Datenbereichs extrapolieren](img/extrapolating.png){#fig-extrapolation}

Sinnvoller ist es da, z.B. einen *Referenzwert* festzulegen, etwa 1950.
Wenn wir dann von allen Jahren 1950 abziehen, wird das Jahr 1950 zum neuen Jahr Null.
Damit bezÃ¶ge sich der Achsenabschnitt auf das Jahr 1950,
was Sinn macht, denn fÃ¼r dieses Jahr haben wir Daten.

Hat man nicht einen bestimmten Wert, der sich als Referenzwert anbietet,
so ist es Ã¼blich, z.B. den Mittelwert als Referenzwert zu nehmen.
Diese Transformation bezeichnet man als *Zentrierung* (engl. centering) der Daten.

```{r}
wetter <-
  wetter %>% 
  mutate(year_c = year - mean(year))  # "c" wie centered
```

Das mittlere Jahr in unserer Messwertereihe ist 1951:

```{r}
wetter %>% 
  summarise(mean(year))
```

```{r}
lm_wetter1c <- lm(temp ~ year_c, data = wetter)
parameters(lm_wetter1c)
```

Jetzt ist die Interpretation des Achsenabschnitts komfortabel:
Im Jahr 1951 (x=0) lag die mittlere Temperatur in Deutschland (laut DWD) bei ca. 8.5 Grad Celcius.


```{r}
r2(lm_wetter1c)
```

Viel Varianz des Wetters erklÃ¤rt `year_c`^[`year` und `year_c` sind gleich stark mit `temp` korreliert, daher wird sich die ModellgÃ¼te nicht unterscheiden.] aber nicht.
Macht auch Sinn: Abgesehen von der Jahreszahl spielt z.B. die Jahreszeit eine groÃŸe Rolle fÃ¼r die Temperatur. Das haben wir nicht berÃ¼cksichtigt.



### BinÃ¤re UV


:::{#def-binvar}
### BinÃ¤re Variable 
Eine *binÃ¤re* UV, auch Indikatorvariable genannt, hat nur zwei AusprÃ¤gungen: 0 und 1.$\square$
:::


:::{#exm-bin}
### BinÃ¤re Variablen 
Das sind zum Beispiel *weiblich* mit den AusprÃ¤gungen `0` (nein) und `1` (ja) oder *before_1950* mit `1` fÃ¼r Jahre frÃ¼her als 1950 und `0` ansonsten.$\square$
:::

:::{#exm-binuv}

Hier interessiert Sie folgende Forschungsfrage: 

>   ğŸ§‘â€ğŸ“ Ob es in der zweiten HÃ¤lfte des 20. Jahrhunderts wohl wÃ¤rmer warm, im Durchschnitt, als vorher?$\square$
:::

Aber wie erstellen Sie eine Variable `after_1950`, um die zweite HÃ¤lfte des 20. Jahrhunderts (und danach) zu fassen?
Nach einigem Ãœberlegen kommen Sie auf die Idee, das vektorisierte Rechnen von R (s. @sec-veccalc) auszunutzen:

```{r}
year <- c(1940, 1950, 1960)
after_1950 <- year > 1950
after_1950
```



Ja, so kÃ¶nnte das klappen! Diese Syntax Ã¼bertragen Sie auf Ihre `wetter`-Daten:

```{r}
wetter <-
  wetter %>% 
  mutate(after_1950 = year > 1950) %>% 
  filter(region != "Deutschland")  # ohne Daten fÃ¼r Gesamt-Deutschland
```


Scheint zu klappen!

Jetzt ein lineares Modell dazu

```{r}
lm_wetter1 <- lm(temp ~ after_1950, data = wetter)
```

Die Parameter des Modells lassen darauf schlieÃŸen, dass es tatsÃ¤chlich wÃ¤rmer war nach 1950, und zwar im Schnitt offenbar ein gutes halbes Grad, s. @fig-wetter2.

```{r}
#| label: fig-wetter2
#| fig-cap: Modell temp ~ after_1950
#| layout-ncol: 2
#| fig-subcap:
#|   - Der SchÃ¤tzbereich fÃ¼r den Parameter reicht von ca. 0.5 bis 0.8 Grad Unterschied
#|   - Wie man sieht, Ã¼berlappen die Temperaturen dennoch betrÃ¤chtlich  
plot(parameters(lm_wetter1))
plot(estimate_expectation(lm_wetter1))
```

Leider zeigt ein Blick zum `r2`, dass die VorhersagegÃ¼te des Modells zu wÃ¼nschen Ã¼brig lÃ¤sst^[`r2(lm_wetter1)`].$\square$
:::


Um die Koeffizienten eines linearen Modells auszurechnen,
benÃ¶tigt man eine metrische X- und eine metrische Y-Variablen.
Hier haben wir aber keine richtige metrische X-Variable^[UV],
sondern eine *logische* Variable mit den Werten `TRUE` und `FALSE`.

Um die X-Variable in eine metrische Variable umzuwandeln, gibt es einen einfachen Trick,
den R fÃ¼r uns ohne viel AnkÃ¼ndigung durchfÃ¼hrt.

:::{.callout-note}
Hat ein nominaler PrÃ¤diktor zwei Stufen, so Ã¼berfÃ¼hrt R diese Variable in eine binÃ¤re Variable.
Da eine binÃ¤re Variable metrisch ist, kann die Regression in gewohnter Weise durchgefÃ¼hrt werden.$\square$
:::

:::: {.columns}

`after_1950` wird in eine Indikatorvariable umgewandelt:

::: {.column width="40%"}

```{r}
#| echo: false

d <- tribble(
  ~id, ~after_1950, ~after_1950TRUE,
  1,   TRUE,       1,
  2,  FALSE,       0
)

d[1:2]
```

:::

::: {.column width="20%"}

$\qquad \rightarrow$

:::

::: {.column width="40%"}
```{r}
#| echo: false

d[c(1,3)]
```
:::
::::



:::: {.columns}

`geschlecht` wird in eine Indikatorvariable umgewandelt:

::: {.column width="40%"}


```{r}
#| echo: false

d2 <- tribble(
  ~id, ~geschlecht, ~geschlechtMann,
  1,   "Mann",       1,
  2,  "Frau",       0
)

d2[1:2]
```

:::

::: {.column width="20%"}

$\qquad \rightarrow$

:::

::: {.column width="40%"}

```{r}
#| echo: false

d2 <- tribble(
  ~id, ~geschlecht, ~geschlechtMann,
  1,   "Mann",       1,
  2,  "Frau",       0
)

d2[1:3]
```

:::
::::


Ein lineares Modell mit binÃ¤rer UV ist nichts anderes die Differenz der Gruppenmittelwerte zu berechnen:

```{r}
wetter %>% 
  group_by(after_1950) %>% 
  summarise(temp_mean = mean(temp))
```

Die Interpretation eines linearen Modells mit binÃ¤rer UV veranschaulicht @fig-binvar: Der Achsenabschnitt (b0) entspricht dem Mittelwert der 1. Gruppe.
Der Mittelwert der 2. Gruppe entspricht der *Summe* aus Achsenabschnitt und dem Koeffizienten der zweiten Gruppe.

```{r}
#| echo: false
#| label: fig-binvar
#| fig-cap: Sinnbild zur Interpretation eines linearen Modells mit binÃ¤rer UV (reingezoomt, um den Mittelwertsunterschied hervorzuheben)

wetter %>% 
  mutate(after1950_TRUE = ifelse(after_1950, 1, 0)) %>% 
  ggplot(aes(x = after1950_TRUE, y = temp)) +
  #geom_violin(alpha = .7) +
  theme_minimal() +
  geom_abline(slope =  coef(lm_wetter1)[2], intercept =  coef(lm_wetter1)[1], color = "grey20") +
  stat_summary(fun = "mean", color = "grey20") + 
  geom_hline(yintercept = coef(lm_wetter1)[1], linetype = "dashed", color = "blue") +
  coord_cartesian(ylim = c(7, 9))  +
  annotate("label", x = Inf, y = coef(lm_wetter1)[1], 
           hjust = "right", label = paste0("b0"), color = "blue") +
  geom_segment(x = 1, y = coef(lm_wetter1)[1], xend = 1, 
               yend = coef(lm_wetter1)[1] + coef(lm_wetter1)[2], 
               color = "red", arrow = arrow()) +
  annotate("label", x = 1 , y = coef(lm_wetter1)[1] + (coef(lm_wetter1)[2] / 2), 
           hjust = "right", label = paste0("b1"), color = "red")  +
  annotate("text", x = 0.5, y = coef(lm_wetter1)[1] + (coef(lm_wetter1)[2] / 2.3),
           color = "grey20", label = "Regressionsgerade", angle = 11, hjust = "bottom") +
  scale_x_continuous(breaks = c(0, 1))
```

Fassen wir die Interpretation der Koeffizienten fÃ¼r das Modell mit binÃ¤rer UV zusammen:

1. Mittelwert der 1. Gruppe: Achsenabschnitt (b0)
2. Mittelwert der 2. Gruppe: Achsenabschnitt (b0) + Steigung der Regressionsgeraden (b1)



### Nominale UV



:::{#exm-wetter2}
Ob es wohl substanzielle^[wie kÃ¶nnte man dieses Wort eigentlich definieren?] Temperaturunterschiede zwischen den BundeslÃ¤ndern gibt?
:::

Befragen wir dazu ein lineares Modell

```{r}
lm_wetter2 <- lm(temp ~ region, data = wetter)
parameters(lm_wetter2)
```

Auch im Fall mehrerer AusprÃ¤gungen einer nominalen Variablen gilt die gleiche Logik der Interpretation wie bei beinÃ¤ren Variablen:



1. Mittelwert der 1. Gruppe: Achsenabschnitt (b0)
2. Mittelwert der 2. Gruppe: Achsenabschnitt (b0) + Steigung der 1. Regressionsgeraden (b1)
3. Mittelwert der 2. Gruppe: Achsenabschnitt (b0) + Steigung der  2. Regressionsgeraden (b2)
4. usw.

Etwas nervig ist, dass das Bundesland, welches als *Referenzgruppe*, sprich als Gruppe des Achsenabschnitts ausgewÃ¤hlt wurde, nicht explizit angegeben ist.

:::{.callout-note}
Soweit nicht anders festgelegt, wÃ¤hlt R die alphabetisch erste Gruppe als Referenzgruppe fÃ¼r ein lineares Modell aus. Der Mittelwert dieser Gruppe entspricht dem Achsenabschnitt.$\square$
:::


:::{#exm-bawÃ¼}
### Achsenabschnitt in wetter_lm2
Da Baden-WÃ¼rttemberg das alphabetisch erste Bundesland ist, wird es von R als Referenzgruppe ausgewÃ¤hlt, dessen Mitelwert als Achsenabschnitt im linearen Modell hergenommen wird.$\square$
:::



Am einfachsten verdeutlicht sich `lm_wetter2` vielleicht mit einem Diagramm, s. @fig-bin-nom.



```{r}
#| echo: false
#| label: fig-bin-nom
#| fig-cap: Sinnbild zur Interpretation eines linearen Modells mit nominaler UV (reingezoomt, um den Mittelwertsunterschied hervorzuheben). Die Achsen wurden um 90Â° gedreht, damit man die Namen der BundeslÃ¤nder besser lessen kann.

wetter_summ <- 
  wetter %>% 
  group_by(region) %>% 
  summarise(temp = mean(temp)) %>% 
  mutate(id = 0:15) %>% 
  ungroup() %>%
  mutate(grandmean = mean(temp),
         delta = temp - grandmean)

wetter_summ %>%  
# filter(region != "Deutschland") %>% 
  ggplot(aes(x = region, y = temp)) +
  theme_minimal() +
  geom_label(aes(label = paste0("b", id),
                 y = grandmean + delta), color = "red", vjust = 1) +
  stat_summary(fun = "mean", color = "grey20") + 
  geom_hline(yintercept = coef(lm_wetter2)[1], linetype = "dashed", color = "blue") +
  coord_cartesian(ylim = c(7, 9))  +
  coord_flip() +
  annotate("label", x = -Inf, y = coef(lm_wetter2)[1], 
           hjust = "top", label = paste0("b0"), color = "blue") +
  annotate("point", x = 1, y = coef(lm_wetter2)[1], color = "blue", size = 4) +
  geom_segment(aes(xend = region, yend = temp), y = coef(lm_wetter2)[1], color = "red") 

```



### BinÃ¤re plus metrische UV


:::{#exm-rain1}
Ob sich die Niederschlagsmenge wohl unterschiedlich zwischen den Monaten entwickelt hat in den letzten gut 100 Jahren?
Der Einfachheit halber greifen Sie sich zwei Monate (Januar und )


```{r}
wetter2 <-
  wetter %>% 
  filter(region == "Bayern"  | region == "Saarland")
```

Okay.
Wie spezifiziert man jetzt das lineare Modell?$\square$
:::

Hat man mehrere PrÃ¤diktoren, so trennt man sich mit einem Plus-Zeichen in der Regressionsformel:

`temp ~ year + region`.

Das Pluszeichen hat hier *keine* arithmetische Funktion. Es wird nichts addiert.
In der Regressionsformel sagt das Pluszeichen nur "und noch folgende UV...".

Die obige Regressionsformel liest sich also so:

>    Temperatur ist eine Funktion von der Jahreszahl und des Bundeslands


```{r}
lm3 <- lm(temp ~ year + region, data = wetter2)
parameters(lm3)
```
Die Modellkoeffizienten sind so zu interpretieren:

1. Achsenabschnitt (b0): Im Jahr Null^[Christi Geburt!] mÃ¼sste  laut dem Modell eine mittlere Jahrestemperatur von -17 Grad geherrscht haben. Unser Datenbereich erstreckt sich etwa 150 Jahre; ohne Daten mal schnell 2000 Jahre zurÃ¼ckzurechnen kann nur in grobe Ungenauigkeit mÃ¼nden. Daher ist der Achsenabschnitt hier nicht zu gebrauchen.
2. Regressionssteigung (b1): Pro Jahr stieg die Temperatur laut dem Modell um 0.01 Grad, in 10 Jahren also um 0,.1 Grad und in 100 Jahren um 1 Grad.

Visualisieren wir uns die geschÃ¤tzten Erwartungswert pro PrÃ¤diktorwert, s. @fig-lm3.

```{r}
#| label: fig-lm3
#| fig-cap: Temperaturverlauf Ã¼ber die Jahre in zwei BundeslÃ¤nder. Man beachte, dass die Regressionsgeraden parallel sind.
plot(estimate_expectation((lm3)))
```


### Interaktion

Die Regressionsformel `temp ~ year + region` zwingt die Regressionsgeraden dazu, parallel zu verlaufen.
Aber vielleicht wÃ¼rden sie besser in die Punktewolken passen, wenn wir ihnen erlauben, auch nicht parallel verlaufen zu dÃ¼rfen.



```{r}
wetter3 <-
  wetter %>% 
  filter(month %in% c(1,7))

lm4 <- lm(precip ~ year * factor(month), data = wetter3)
parameters(lm4)
plot(estimate_expectation(lm4))
```





















## Vertiefung

:::{#exm-wetter3}
Als nÃ¤chstes mÃ¶chten Sie untersuchen, wie groÃŸ der Temperaturunterschied im Schnitt zwischen den Monaten ist.


```{r}
lm_wetter2 <- lm(temp ~ month, data = wetter)
parameters(lm_wetter2)
```

Moment! `month` ist als metrische Variable in der Tabelle reprÃ¤sentiert.
Aber der Monat sollte besser eine *nominale* Variable sein.
:::



## Aufgaben



## Literatur
