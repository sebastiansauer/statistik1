## Fallstudie Immobilienpreise


:::{.callout-caution}
Diese Fallstudie stellt die Prüfungsleistung "Prognosewettbewerb" einführend dar. 
Es empfiehlt sich für Sie, diese Fallstudie sorgsam zu bearbeiten.$\square$
:::


### Hintergrund

In dieser Fallstudie geht es darum, die Preise von Immobilien vorherzusagen.
Kurz gesagt: Sagen Sie die Hauspreise vorher, und reichen Sie Ihre Vorhersagen als CSV bei [Kaggle](https://www.kaggle.com/) ein.

Kaggle ist eine Webseite, die Prognosewettbewerbe veranstaltet. 


In dieser Fallstudie nehmen Sie teil an der Kaggle-Competition [Ames House Prices](https://www.kaggle.com/competitions/house-prices-advanced-regression-techniques/overview).

- [Beschreibung](https://www.kaggle.com/competitions/house-prices-advanced-regression-techniques/overview/description)
- [Ziel/Aufgabe](https://www.kaggle.com/competitions/house-prices-advanced-regression-techniques/overview/evaluation)
- [Spielregeln](https://www.kaggle.com/competitions/house-prices-advanced-regression-techniques/rules)


### Benötigte R-Pakete

```{r}
#| message: false
library(tidyverse)
library(easystats)
```



### Daten

Wenn Sie sich bei Kaggle einloggen möchten, können Sie die Daten von Kaggle herunterladen und zwar [hier](https://www.kaggle.com/competitions/house-prices-advanced-regression-techniques/data).

Im Einzelnen müssen Sie folgende Dateien herunterladen:

- *Data_description.txt*: Code book, d.h. Beschreibung der Variablen im Datensatz
- *train.csv*: Daten von Häusern, die Sie nutzen, um Modelle zu erstellen
- *test.csv*:  Daten von Häusern, von denen Sie den Kaufpreis vorhersagen sollen
- *sample_submission.csv*: Beispielhafte Prognosedatei, die Datei also, mit der Sie Ihre Vorhersagen einreichen


Sie können auch so auf die Daten zugreifen:


```{r}
d_train_path_online <- "https://raw.githubusercontent.com/sebastiansauer/Lehre/main/data/ames-kaggle/train.csv"
d_test_path_online <- "https://raw.githubusercontent.com/sebastiansauer/Lehre/main/data/ames-kaggle/test.csv"

d_train <- read_csv(d_train_path_online)
d_test <- read_csv(d_test_path_online)
```



Laden Sie diese Daten am besten herunter und speichern Sie sie in einem passenden Unterverzeichnis (Ihres Projektordners in RStudio) ab.

Das Code Book können Sie [hier einsehen und herunterladen](https://github.com/sebastiansauer/Lehre/blob/main/data/ames-kaggle/data_description.txt).


### Prognosedatei


Die Prognosedatei soll prinzipiell so aussehen:

```{r read-data-ames}
#| echo: false
sample_subm_path <- "daten/ames-kaggle/sample_submission.csv"
sample_subm <- readr::read_csv(sample_subm_path)
head(sample_subm)
```

Die Prognosedatei besteht also aus zwei Spalten: der Spalte `id` und der Spalte `Saleprice`.
Die Spalte `id` gibt an, welches Haus in einer bestimmten Zeile Ihrer Prognosedatei gemeint ist - für welches Haus Sie also gerade einen Kaufpreis vorhersagen.
die Spalte `SalePrice` ist Ihre Vorhersage für den Kaufpreis das Hauses mit der Id, die in der betreffenden Zeile steht.
Insgesamt soll die Prognosedatei genau so viele Zeilen haben wie der Test-Datensatz, also die Tabelle, die die vorherzusagenden Werte angibt.



Alles klar? 

Los geht's!


### Daten importieren

Wir starten die üblichen R-Pakete und importieren die Daten (`d`):


```{r}
library(tidyverse)
library(easystats)
```


```{r read-data-local}
#| message: false
d_train_path <- "daten/ames-kaggle/train.csv"
d_test_path <- "daten/ames-kaggle/test.csv"
d_train <- read_csv(d_train_path)
d_test <- read_csv(d_test_path)
```




:::{.callout-note}
In diesem Beispiel gehen wir davon aus, dass die Dateien `train.csv` und `test.csv` in einem Unterordner namens `daten/ames-kaggle` liegen.
Sie müssen sie dort abspeichern.
Dieser Ornder muss ein Unterordner Ihres aktuellen R-Projekts sein.$\square$
:::

:::{.callout-caution}
Wenn das Importieren von der Festplatte nicht klappt ... 
Es ist hilfreich, wenn man Daten von der eigenen Festplatte importieren kann.
Aber fürs Erste können Sie die Daten auch von oben angegeben Online-Pfad importieren.$\square$
:::

```{r}
#| eval: false
d_train <- read_csv(d_train_path_online)
d_test <- read_csv(d_test_path_online)
```

### Ein erster Blick in die Daten

Schauen wir uns einmal die Verteilung der metrischen Variablen an, 
@tbl-ames1.

```{r}
#| label: tbl-ames1
#| tbl-cap: Verteilung der metrischen Variablen im ames-Datensatz 
describe_distribution(d_train)
```



### Ein erstes Vorhersagemodell


#### Welche Variablen eignen sich zur Vorhersage?


Eine einfache Antwort auf die Frage, welche Variablen sich zur Vorhersage eignen, ist, 
die Korrelation aller Prädiktoren mit der abhängigen Variablen^[die vorherzusagende Variable, auch Ziel- oder Outcome-Variable genannt] zu berechnen, s. @tbl-d_train_corr.

```{r}
#| results: hide
d_train %>% 
  select(-Id) %>% 
  correlation() %>%  # berechne Korrelationen
  filter(Parameter2 == "SalePrice") %>%   # aber nur, wo die zweite Variable "SalesPrice" ist
  arrange(-abs(r)) %>%   # sortiere absteigend nach der Höhe des Korrelationskoeffizienten r
  filter(abs(r) > .3)  # nur |r| > 3.
```


```{r}
#| echo: false
#| label: tbl-d_train_corr
#| tbl-cap: "Korrelation der Prädiktoren (UV) mit der AV"
d_train %>% 
  select(-Id) %>% 
  correlation() %>%  # berechne Korrelationen
  filter(Parameter2 == "SalePrice") %>%   # aber nur, wo die zweite Variable "SalesPrice" ist
  arrange(-abs(r)) %>%   # sortiere absteigend nach der Höhe des Korrelationskoeffizienten r
  filter(abs(r) > .3)  %>%  # nur |r| > 3.
  print_md()
```

Aha! Ein Menge Information.^[Wenn Sie Teile der Ausgabe der Tabelle nicht verstehen: Im Zweifel einfach ignorieren. Wenn Sie die R-Syntax nicht verstehen: Führen Sie die Syntax schrittweise aus. Zuerst `d_train` ausführen und das Ergebnis betrachten. Dann `d_train %>% select(-Id)` ausführen, wieder die Ausgabe betrachten, usw.]

Diese Variablen sind einigermaßen stark mit unserer Zielvariablen `SalePrice` korreliert.
Nutzen wir also diese Variablen (oder einige von ihnen) zur Vorhersage.


#### Model 1

Berechnen wir ein erstes Modell für diese Forschungsfrage, s. @tbl-m1-params.

```{r}
#| results: hide
m1 <- lm(SalePrice ~ OverallQual + GrLivArea + GarageCars, data = d_train)
parameters(m1)
```


```{r}
#| echo: false
#| label: tbl-m1-params
#| tbl-cap: "Modellparameter von m1"
parameters(m1) %>% print_md()
```


Wie gut sind die Vorhersagen des Modells für die Daten von `d_train`?


```{r}
rmse(m1)
```


Im Schnitt liegen unsere Vorhersagen ca. 40 Tausend Dollar daneben. Ist das gut?


```{r}
r2(m1)
```

Ob das R-Quadrat "gut" oder "hoch" ist, beantwortet man am besten *relativ*, 
also im Vergleich zu anderen Modellen.


#### Nullmodell

Zum Vergleich berechnen wir das maximal einfache Modell: ohne Prädiktoren.
Man nennt es das "Nullmodell".
In diesem Modell sagen wir für jedes Haus einfach den mittleren Preis aller Häuser vorher.



```{r}
m0 <- lm(SalePrice ~ 1, data = d_train)
```


Wie gut ist die Vorhersage des Nullnomdells?

```{r}
rmse(m0)
```


Das R-Quadrat der Nullmodells ist per Definition Null:


```{r}
r2(m0)
```


### Vorhersagen im Test-Datensatz

Wir haben jetzt unseren Champion, `m1`.
Alle Hoffnung ruht auf diesem Modell.
Ob die Vorhersagen im Test-Sample präzise sein werden?
Oder himmelweit daneben?
Bitte, enttäusche uns nicht!


Hier sind die Vorhersagen:


```{r}
m1_pred <- predict(m1, newdata = d_test)  # <1> 
head(m1_pred) # <2>
```
1. predicte anhand der Regressionsgerade von m1 und zwar anhand der Daten aus `d_test`
2. zeige den "Kopf" der Vorhersagen (`m1_pred`), d.h. die ersten paar Vorhersagen



Die Vohersagen fügen wir jetzt dem Test-Sample hinzu:

```{r}
d_test <- 
  d_test %>% 
  mutate(SalePrice = m1_pred)
```


### Einreichen!


So, wir haben unsere Vorhersagen!
Jetzt reichen wir diese Vorhesagen ein.

Für die Prognosedatei (submission file) zum Einreichen brauchen wir nur die Spalten `id` und `SalePrice`:


```{r}
m1_subm <-
  d_test %>% 
  select(Id, SalePrice)
```


Kaggle möchte keine fehlenden Werten in den Vorhersagen, also prüfen wir das mal:

```{r}
#| eval: true
#| code-annotations: hover
m1_subm %>% 
  drop_na() %>%  # <1>
  nrow()         # <2>
```
1. Lass alle Zeilen mit NAs (fehlenden Werten in irgendeiner Spalte) fallen, filtere diese Zeilen also raus
2. zähle die Anzahl der Zeilen


Oh, das ist *eine* Zeile weniger! Wir haben also einen fehlenden Wert!

Filtern wir die Spalte `SalePrice` mal nach "ist NA":

```{r}
m1_subm %>% # <1)
  filter(is.na(SalePrice)) # <2>
```

Übersetzen wir die Syntax auf Detusch:

1. Nimm zuerst die Tabelle `m1_smb`
2. Filter dann so, dass du nur Zeilen hast, für die gilt, "hier ist ein NA in der Spalte `SalePrice`

Ah, da ist er, der fehlende Wert, in Zeile 2577!
Hinfort!

Wir ersetzen die fehlenden Werte in `SalePrice` mit dem Mittelwert von `SalePrice`:

```{r}
m1_subm_nona <- # <1>
  m1_subm %>%  # <2>
  mutate(SalePrice = replace_na(SalePrice, mean(SalePrice, na.rm = TRUE))) # <3>
```

Die Syntax wieder auf Deutsch:

1. Definiere `m1_subm_nona` wie folgt
2. Nimm `m1_subm` und dann
3. Verändere die Spalte `SalePrice` und zwar so, dass NAs ersetzt werden durch den Mittelwert von `SalePrice`


Und? Gib es jetzt noch fehlende Werte?

```{r}
m1_subm_nona %>% 
  filter(is.na(SalePrice))
```

Nein! Die Ergebnistabelle hat null Zeilen. 
"No NA" - Keine NAs, keine fehlenden Werte mehr.

Diesen Tibble speichern wir als CSV-Datei an geeigneter Stelle ab.^[Es bietet sich an `write_csv` zu verwenden, da `write.csv` automatisch (ungefragt) noch eine Id-Spalte  ohne Namen einfügt (mit den Zeilennummern), das mag aber Kaggle nicht. Kaggle erwartet exakt zwei Spalten und zwar mit den Namen `Id` und `SalePrice`].


```{r}
write_csv(m1_subm_nona, "daten/ames-kaggle/m1-subm.csv")
```

Und dann laden Sie diese Datei, `m1_subm.csv` bei Kaggle hoch und hoffen auf einen Hauptgewinn.

Das Modell erzielte einen Score von *0.55521*.



### Debrief

Diese Fallstudie hat ein einfaches Prognosemodell vorgestellt.
Sicherlich gibt es viele Ansätze, dieses Modell zu verbessern.

Hier sind einige Fragen, die Sie sich dazu stellen können:

- Welche Prädiktoren sollte ich in das Modell aufnehmen?
- Wie gehe ich mit fehlenden Werten um?
- Wenn ein Prädiktor schief ist, sollte ich ihn dann log-transformieren?
- Vielleicht sollte man manche Prädiktoren quadrieren?
- Wie gehe ich mit nominalskalierten Variablen um, wenn diese viele Stufen haben?
- ...

Viel Spielraum für Ihre Kreativität!









