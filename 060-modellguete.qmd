# Modellg√ºte




```{r libs-hideen}
#| echo: false
library(patchwork)
library(ggpubr)
library(tidyverse)
library(easystats)
library(DataExplorer)
```



```{r}
#| echo: false
source("_common.R")
```




{{< include children/colors.qmd >}}






## Einstieg



In diesem Kapitel ben√∂tigen Sie √ºblichen R-Pakete (`tidyverse`, `easystats`) und Daten (`mariokart`),  s. @sec-import-mariokart.


::: {.content-visible when-format="html"}

```{r}
#| message: false
library(tidyverse)
library(easystats)
```


```{r import-mariokart-csv}
mariokart <- read.csv("https://vincentarelbundock.github.io/Rdatasets/csv/openintro/mariokart.csv")
```
:::





### Lernziele


- Sie kennen g√§ngige Ma√üe der Streuung einer Stichprobe und k√∂nnen diese definieren und mit Beispielen erl√§utern.
- Sie k√∂nnen g√§ngige Ma√üe der Streuung einer Stichprobe mit R berechnen.
- Sie k√∂nnen die Bedeutung von Streuung f√ºr die G√ºte eines Modells erl√§utern.








:::: {.content-visible when-format="html" unless-format="epub"}

:::{#exr-streuung-erkennen}
### Freiwillige vor! 
F√ºr diese kleine Live-Demonstration brauchen wir einige Freiwillige. 
Die Lehrkraft teilt die Freiwilligen in zwei Gruppen, Gruppe *Gleich-Gro√ü* und Gruppe *Verschieden-Gro√ü*. 
Erkennen Sie, dass die *Unterschiedlichkeit* der Gr√∂√üe in Gruppe *Gleich-Gro√ü* gering ist, aber in Gruppe *Verschieden-Gro√ü* hoch? $\square$
:::
::::
  




### Die Schlankheitspille von Prof. Weiss-Ois  {#sec-weiss-ois}

Prof. Weiss-Ois hat eine Erfindung gemacht, eine Schlankheitspille[üíä]{.content-visible when-format="html"} [@flaticon_professor_2024].
  

:::{#fig-prof layout="[10,-2,10]"}


![**Was er sagt:** "Ich habe eine Schlankheitspille entwickelt, die pro Einnahme das Gewicht im Schnitt um 1kg reduziert!"](img/teacher.png){width="25%"}



![**Was er NICHT sagt:** "Allerdings streuten die Werte der Gewichtsver√§nderung um 10kg um den Mittelwert herum."](img/teacher.png){width="25%"}

:::






:::{#exr-weisoiss2}
W√ºrden Sie die Pille von Prof. I. Ch. Weiss-Ois nehmen?

a) ja, ich zahle 1000 Euro
b) ja
c) nein
d) Nur wenn ich 100 Euro bekomme
e) Okay, f√ºr 1000 Euro$\square$
:::



Wie sehr die Werte eines Modells streuen, ist eine wichtige Information:
Bei Prof. Weiss-Ois' Pille kann es sein, dass Sie 10 kg *zunehmen*, 
wenn Sie die Pille einnehmen.



### Wie man seine Kuh √ºber den Fluss bringt

Treffen sich zwei Bauern, Fritz Furchenzieher und Karla Kartoffelsack.
Fritz will mit seiner Kuh einen Fluss √ºberqueren, nur kann die Kuh nicht schwimmen (ob es Fritz kann, ist nicht √ºberliefert).


>    [üë®‚Äçüåæ]{.content-visible when-format="html"}[\emoji{man-farmer}]{.content-visible when-format="pdf"} (Fritz): Sag mal, Karla, ist der Fluss tief?

>    [üë©‚Äçüåæ]{.content-visible when-format="html"}[\emoji{woman-farmer}]{.content-visible when-format="pdf"} (Karla): N√∂, im Schnitt nur einen Meter.


Also f√ºhrt Fritz seine Kuh durch den Fluss, leider kam die Kuh nicht am anderen Ufer an, da fim Flo√ü ersoffen, s. @fig-fluss-tief.

![Der Fluss ist im Schnitt nur einen Meter tief, trotzdem ist die Kuh ersoffen.](img/fluss-tief.png){#fig-fluss-tief}


>    [üë©‚Äçüåæ]{.content-visible when-format="html"}[\emoji{woman-farmer}]{.content-visible when-format="pdf"} (Karla): √úbrigens, Lagema√üe sagen nicht alles, Fritz.

>    [üë®‚Äçüåæ]{.content-visible when-format="html"}[\emoji{man-farmer}]{.content-visible when-format="pdf"} (Fritz): L√§uft die Kuh durch den Fluss, kann sie schwimmen oder 's ist Schluss.


:::{.callout-important}
Die Streuung ihrer Daten zu kennen ist eine wesentliche Information. $\square$
:::




## Woran erkennt man ein gutes Modell?








@fig-streuung zeigt ein einfaches Modell (Mittelwert) mit wenig Streuung (links) vs. ein einfaches Modell mit viel Streuung (rechts).
Links ist die Streuung der Schlankheitspille *Dicktableitin* 
und rechts von der Schlankheitspille *Pfundafliptan* abgetragen.
Die vertikalen grauen Balken in @fig-streuung kennzeichnen den (absoluten) 
Abstand von jeweils einem Datenpunkt zum Mittelwert (horizontale orange Linie). 
Je l√§nger die vertikalen 'Abstandsbalken' insgesamt, desto gr√∂√üer die Streuung.
Die X-Achse (`id`) reiht die Versuchspersonen auf.

```{r viel-wenig-streuung}
#| echo: false
#| label: fig-streuung
#| out-width: 100%
#| fig-cap: "Wenig (links) vs. viel Streuung (rechts)."


set.seed(42)
d <-
  tibble(
    id = 1:100,
    x1 = rnorm(100, 0, 1),
    x2 = rnorm(100, 0, 7)
  ) %>% 
  pivot_longer(-id) %>% 
  group_by(name) %>% 
  mutate(avg = mean(value),
         e = value - avg) %>% 
  ungroup()

d_sum <-
  d %>% 
  group_by(name) %>% 
  summarise(avg = mean(value))

group_names <-
  c(x1 = "wenig Streuung:\nDiktableibtin",
    x2 = "viel Streuung:\nPfundafliptan")

d %>% 
  ggplot(aes(x = id, y = value)) +
  geom_point() +
  facet_wrap(~ name, labeller = as_labeller(group_names)) +
  geom_hline(color = okabeito_colors()[1], yintercept = 0) +
  geom_segment(aes(x = id, xend = id, y = value, yend = avg), 
               alpha = .5, color = "grey") +
  theme_minimal() +
  geom_label(x = 0, y = 0, label = "MW", color = okabeito_colors()[1]) +
  scale_x_continuous(limits = c(-10,100))
```


Bei einem Modell mit *wenig* Streuung liegen die tats√§chlichen, beobachtete Werte ($y$) nah an den Modellwerten (vorhergesagten Werten, $\hat{y}$); 
die Abweichungen $e = y - \hat{y}$ sind also gering (der Modellfehler ist klein).
Bei einem Modell mit *viel* Streuung ist der Modellfehler $e$ (im Vergleich dazu) gro√ü.





:::{#exm-weiss-ois}
### Daten zur Schlankheitskur von Prof. Weiss-Ois
In @fig-streuung sind die Daten zu der Gewichtsver√§nderung nach Einnahme von "Schlankheitspillen" zweier verschiedener Pr√§parate. 
Wie man sieht, unterscheidet sich die typische (vorhergesagte, mittlere) Gewichtsver√§nderung zwischen den beiden Pr√§paraten kaum. Die Streuung allerdings schon.
Links sieht man die Gewichtsver√§nderungen nach Einnahme des Pr√§parats "Dickableibtin extra mild" (c) und rechts das Pr√§parat von Prof. Weiss-Ois "Pfundafliptan Forte".
Welches Pr√§parat w√ºrden Sie lieber einnehmen?$\square$
:::





Wir wollen ein pr√§zises Modell, also kurze Fehlerbalken: 
Das Modell soll die Daten gut erkl√§ren, 
also wenig vom tats√§chlichen Wert abweichen.
Jedes Modell sollte Informationen √ºber die Pr√§zision des Modellwerts bzw. der Modellwerte (Vorhersagen) angeben. 
Ein Modell ohne Angaben der Modellg√ºte, d.h. der Pr√§zision der Sch√§tzung des Modellwerts, ist wenig n√ºtze.





>    [üßë‚Äçüéì]{.content-visible when-format="html"}[\emoji{student}]{.content-visible when-format="pdf"}
Ich frage mich, ob man so ein Modell nicht verbessern kann?

>    [üßë‚Äçüè´]{.content-visible when-format="html"}[\emoji{teacher}]{.content-visible when-format="pdf"} Die Frage ist, was wir mit "verbessern" meinen?

>    [üßë‚Äçüéì]{.content-visible when-format="html"}[\emoji{student}]{.content-visible when-format="pdf"} Naja, k√ºrzere Fehlerbalken, ist doch klar!

Im Beispiel von Mariokart: 
Da die Anzahl der Lenkr√§der mit dem Verkaufspreis zusammenh√§ngt, 
k√∂nnte es vielleicht sein, 
dass wir die Lenkr√§der-Anzahl da irgendwie nutzen zur Vorhersage k√∂nnten.
Das sollten wir ausprobieren.
@fig-fehler-red zeigt, dass die Fehlerbalken *k√ºrzer* werden, wenn wir ein (sinnvolles) komplexeres Modell finden.
Innerhalb jeder der beiden Gruppen (mit 2 Lenkr√§dern vs. mit 0 Lenkr√§dern) 
sind die Fehlerbalken jeweils im Durchschnitt k√ºrzer (rechtes Teildiagramm) als im Modell ohne Gruppierung (linkes Teildiagramm).
Aus Gr√ºnden der √úbersichtlichkeit wurden nur Autos mit Verkaufsgebot 
von weniger als 100 Euros ber√ºcksichtigt und nur Spiele mit 0 oder mit 2 Lenkr√§dern.




```{r fehlerbalken}
#| echo: false
#| label: fig-fehler-red
#| fig-cap: "Fehlerbalken in einem einfachen und komplexeren Modell. (a) Fehlerbalken im einfachen Modell. Ein Mittelwert; viel Streuung insgesamt, y ~ 1. (b) Fehlerbalken im komplexen Modell. Zwei Mittelwerte; weniger Streuung in jeder Gruppe, y ~ G. Das erkennt man daran, dass die vertikalen, grauen Abstandsbalken im Schnitt k√ºrzer sind als im einfachen Modell."
#| layout-ncol: 2
#| fig-subcap:
#|   - "Einfaches Modell"
#|   - "Komplexeres Modell"
#| out-width: 100%
 
data(mariokart, package = "openintro")
m <-
  mariokart %>%
  filter(total_pr < 100) %>% 
  filter(wheels %in% c(0, 2)) %>% 
  mutate(ID = 1:nrow(.),
         total_pr_resid = total_pr - mean(total_pr),
         total_pr_resid_quad = total_pr_resid^2) %>% 
  group_by(wheels) %>% 
  mutate(total_pr_mean_group = mean(total_pr)) %>% 
  ungroup()


m_sum <- 
  m %>% 
  group_by(wheels) %>% 
  summarise(total_pr = mean(total_pr)) %>% 
  ungroup()


m %>% 
  ggplot() +
  geom_hline(aes(yintercept = mean(total_pr))) +
  geom_segment(aes(x = ID,
                   xend = ID,
                   y = total_pr,
                   yend = mean(total_pr)
                   ), color = "grey") +
  geom_point(aes(x = ID, y = total_pr)) +
  annotate("label", x = 0, y = 47, label = "MW", hjust = "left", size = 6) +
  theme_large_text()



m %>% 
  ggplot() +
  geom_segment(data = filter(m, wheels == 0),
               aes(x = ID,
                   xend = ID,
                   y = total_pr,
                   yend = mean(total_pr)
               ), color = "grey") +
   geom_hline(data = m_sum,
     aes(yintercept = total_pr,
                 color = factor(wheels))) +
   geom_segment(data = filter(m, wheels == 2),
               aes(x = ID,
                   xend = ID,
                   y = total_pr,
                   yend = mean(total_pr)
               ), color = "grey") +
  geom_point(
    aes(x = ID, y = total_pr, color = factor(wheels))) +
  labs(color = "wheels") +
  theme(legend.position = "none") +
  geom_label(data = m_sum,
    aes(label = paste0("MW bei ", wheels, " R√§der"), 
        y = total_pr, color = factor(wheels)), 
    x = max(m$ID), hjust = 1, size = 6,
    show.legend = FALSE) +
  scale_color_okabeito() +
  scale_x_continuous(limits = c(-10, 90)) +
  theme_large_text()
```


:::{.callout-important}
Durch sinnvolle, komplexere Modelle sinkt die Fehlerstreuung eines Modells. $\square$
:::


## Streuungsma√üe {#sec-streuung}

:::{#def-streuungsma√üe}
### Streuungsma√üe
Ein Streuungsma√ü quantifiziert die Variabilit√§t (Unterschiedlichkeit, Streuung) eines Merkmals. $\square$
:::

:::{#def-range}
### Spannweite
Ein einfaches Streuungsma√ü ist die *Spannweite* (Range) $R$, 
definiert als Differenz von gr√∂√ütem und kleinsten Wert eines Merkmals X: $R := X_{max} - X_{min}. \square$
:::

:::{#exm-range}
Angenommen, wir haben einen Datensatz zum Merkmal "Alter" mit den Werte 1, 23, 42, 100. 
Dann betr√§gt der Range: $R = 100 - 1 = 99$. 
Das bedeutet, dass die Werte des Merkmals √ºber 99 Einheiten (Jahre in diesem Fall) 
verteilt sind. $\square$
:::

Die Spannweite ist aber nicht robust (gegen√ºber Extremwerten) und sollte daher nur mit Einschr√§nkung verwendet werden.


### Der mittlere Abweichungsbalken

>    [üßë‚Äçüéì]{.content-visible when-format="html"}[\emoji{student}]{.content-visible when-format="pdf"}
 Wir m√ºssen jetzt mal pr√§ziser werden! Wie k√∂nnen wir die Streuung berechnen?

>    [üßë‚Äçüè´]{.content-visible when-format="html"}[\emoji{teacher}]{.content-visible when-format="pdf"} Gute Frage! Am einfachsten ist es, wenn wir die mittlere L√§nge eines Abweichungsbalkens ausrechnen. 



Legen wir (gedanklich) alle Abweichungsbalken $e$ aneinander und teilen durch die Anzahl $n$ der Balken,
so erhalten wir wir den "mittleren Abweichungsbalken",
den wir mit $\bar{e}$ bezeichnen k√∂nnten.
Diesen Kennwert bezeichnet man als *Mean Absolute Error* (MAE) 
bzw. als *mittlere Absolutabweichung* (MAA), s. @eq-mae.




:::{#def-mae}
### Mittlere Absolutabweichung
Die Mittlere Absolutabweichung (MAA, MAE) ist definiert als die Summe der Absolutwerte 
der Differenzen eines Messwerts zum Mittelwert, 
geteilt durch die Anzahl der Messwerte. (Wenn man solche S√§tze liest, 
f√ºhlt sich die Formel fast einfacher an.)


$${\displaystyle \mathrm {MAE} :={\frac {\sum _{i=1}^{n}\left|y_{i}-\bar{y}\right|}{n}}={\frac {\sum _{i=1}^{n}\left|e_{i}\right|}{n}}=\bar{e}.  \; \square}$$ {#eq-mae}

:::

:::{#exm-mae}
@fig-mae visualisiert ein einfaches Beispiel zum MAE.
Rechnen wir den MAE f√ºr das Beispiel von @fig-mae aus:

$MAE = \frac{1 + |- 3| + 1 + 1}{4} = 6/4 = 1.5 \quad \square$
:::

```{r mae-balken}
#| echo: false
#| label: fig-mae
#| fig-cap: "Abweichungsbalken und der MAE"
#| fig-asp: .5
#| out-width: 50%
d <-
  tibble(id = 1:4,
         y = c(1, -3, 1, 1))


ggplot(d) +
  aes(x = id, y = y) +
  geom_point(size = 5, alpha = .7, color = ycol) +
  geom_segment(aes(x = id, xend = id, y = y, yend = mean(y))) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  annotate("label", x = 0.5, y = 0, label = "Mittelwert") +
  theme_minimal() +
  scale_x_continuous(limits = c(0, 4))
```

Nat√ºrlich k√∂nnen wir R auch die Rechenarbeit √ºberlassen.

>    [ü§ñ]{.content-visible when-format="html"}[\emoji{robot}]{.content-visible when-format="pdf"} Loving it!!


Schauen Sie: Den Mittelwert (s. @fig-mae) kann man doch mit Fug und Recht als ein *lineares Modell*, eine Gerade, betrachten, oder nicht?
Schlie√ülich erkl√§ren wir $y$ anhand einer Gerade (die parallel zur X-Achse verl√§uft).
In R gibt es einen Befehl, um ein *l*ineares *M*odell zu berechnen,
er hei√üt `lm`.
Die Syntax von `lm()` lautet: `lm(y ~ 1, data = meine_daten)`.

In Worten: 

>   Hey R, berechne mit ein lineares Modell zur Erkl√§rung von Y. Aber verwende keine andere Variable zur Erkl√§rung von Y, sondern nimm den Mittelwert von Y.

```{r}
lm1 <- lm(y ~ 1, data = d)
```


Den MAE k√∂nnen wir uns jetzt so ausgeben lassen:

```{r}
mae(lm1)  # aus dem Paket easystats
```




### Der Interquartilsabstand


Der Interquartilsabstand (IQA; engl. inter quartile range, IQR) 
ist ein Streuungsma√ü, das nicht auf dem Mittelwert aufbaut.
Der IQR ist robuster als z.B. der MAA oder die Varianz und die Standardabweichung.
@fig-iqr-mario stellt den IQR (und einige Quantile) 
f√ºr den Verkaufspreise von Mariokart-Spielen dar.


:::{#def-iqr}
### Interquartilsabstand
Der Interquartilsabstand ist definiert als der die (absolute) Differenz vom 3. Quartil und 1. Quartil: $IQR := Q_3-Q_1. \; \square$
:::


:::{#exm-iqr}
### IQR im H√∂rsaal
In einem Statistikkurs betragen die Quartile der K√∂rpergr√∂√üe: Q1: 1.65m, Q2 (Median): 1,70m, Q3: 1.75m. 
Der IQR betr√§gt dann: $IQR = Q_3-Q_1 = 1.75 \; m - 1.65\;  m = 0.10\; m$, d.h. 10 cm. $\square$
:::






```{r}
#| echo: false
#| layout-ncol: 2
#| label: fig-iqr-mario
#| fig-cap: "IQR, Q1, Q2 und Q3 f√ºr das Schlussgebot (nur Spiele f√ºr weniger als 100 Euro)"
#| fig-subcap: 
#|   - "Histogramm"
#|   - "Dichtediagramm"

mario_quantile2 <- 
mariokart %>% 
  filter(total_pr < 100) %>% 
  summarise(q25 = quantile(total_pr, .25),
            q50 = quantile(total_pr, .50),
            q75 = quantile(total_pr, .75))

mario_quantile <- 
  mariokart %>% 
  filter(total_pr < 100) %>% 
  reframe(qs = quantile(total_pr, c(.25, .5, .75)))

mariokart %>% 
  filter(total_pr < 100) %>%  
  ggplot(aes(x = total_pr)) +
  geom_histogram() +
  geom_vline(xintercept = mario_quantile$qs) +
  annotate("label", x =  mario_quantile$qs, y = 0, label =  mario_quantile$qs) +
  annotate("label", x =  mario_quantile$qs, y = Inf, label =  c("Q1", "Median", "Q3"), vjust = 2) +
  labs(y = "Anzahl") +
  geom_segment( 
           aes(x = q25, xend = q75), 
           y = 5, yend = 5, color = "#56B4E9",
           data = mario_quantile2, size = 3) +
  annotate("label", x = mario_quantile2$q50, y = 5,
           label = "IQR", color = "#56B4E9") +
  theme_large_text()

mariokart %>% 
  filter(total_pr < 100) %>%  
  ggplot(aes(x = total_pr)) +
  geom_density() +
  geom_vline(xintercept = mario_quantile$qs) +
  annotate("label", x =  mario_quantile$qs, y = 0, label =  mario_quantile$qs) +
  annotate("label", x =  mario_quantile$qs, y = Inf, label =  c("Q1", "Median", "Q3"), vjust = 2) +
  labs(y = "Anteil") +
  geom_segment( 
           aes(x = q25, xend = q75), 
           y = 0.01, yend = 0.01, color = "#56B4E9",
           data = mario_quantile2, size = 3) +
  annotate("label", x = mario_quantile2$q50, y = .01,
           label = "IQR", color = "#56B4E9")  +
  scale_y_continuous(labels = NULL) +
  theme_large_text()
```




### Streuungsma√üe f√ºr Normalverteilungen

Normalverteilungen sind recht h√§ufig anzutreffen in der Praxis der Datenanalyse.
Daher lohnt es sich, zu √ºberlegen,
wie man diese Verteilungen gut zusammenfassen kann.
Man kann zeigen, dass eine Normalverteilung sich 
komplett √ºber ihren *Mittelwert* sowie ihre *Standardabweichung* beschreiben l√§sst [@lyon_why_2014].
Au√üerdem gilt: Sind Ihre Daten normalverteilt, 
dann sind die Abweichungen vom Mittelwert auch normalverteilt.
Denn wenn man eine Konstante zu einer Verteilung addiert (bzw. subtrahiert), 
"verschiebt man den Berg" ja nur zur Seite, 
ohne seine Form zu ver√§ndern, s. @fig-norm-dev.



```{r fig-norm-verschieb-pfeil}
#| echo: false
#| label: fig-norm-dev
#| fig-cap: "Die Abweichungen zum Mittelwert (MW) einer normalverteilten Variable sind selber normalverteilt. Rechts: unzentrierte Verteilung; links: zentriert."
#| fig-asp: 0.5
#| out-width: 75%

mw <- 47.4
streuung <- 9.11

d <- 
  tibble(groesse = rnorm(1e5, mw, streuung),
         groesse_zentriert = groesse - mean(groesse))

d_sum <-
  d %>% 
  pivot_longer(everything()) %>%
  group_by(name) %>% 
  summarise(MW = mean(value))
  

d %>% 
  ggplot() +
  stat_function(fun = dnorm,
                args = list(mean = 0, sd = streuung), 
                color = okabeito_colors()[1]) +
  stat_function(fun = dnorm,
                args = list(mean = mw, sd = streuung), 
                color = okabeito_colors()[2]) +
  #geom_density(aes(x = groesse), color = "#E69F00FF", size = 2) +
  #geom_density(aes(x = groesse_zentriert), color = "#56B4E9FF", size = 2) +
  theme_minimal() +
  geom_vline(
             xintercept = mw,
             color = "grey") +
  geom_vline(
             xintercept = 0,
             color = "grey") +
  annotate("label", x = 0, y = 0, label = "MW: 0") +
  annotate("label", x = mw, y = 0, label = paste0("MW: ", mw)) +
  labs(x = "(zentrierte) Variable", 
       y = "") +
  annotate("segment", x = mw, xend = 0, y = 0.01, yend = 0.01,
           arrow = arrow(type = "closed", length = unit(0.02, "npc"))) +
  scale_y_continuous(labels = NULL) +
  scale_x_continuous(limits = c(-50, 100))



# d %>% 
#   pivot_longer(everything()) %>% 
#   ggplot() +
#   aes(x = value) +
#   geom_density() +
#   facet_wrap(~ name) +
#   theme_minimal() +
#   geom_vline(data = d_sum,
#              aes(xintercept = MW), color = "red") +
#   geom_label(data = d_sum,
#              aes(label = paste0("MW: ", round(MW, 0)), x = MW),
#              y = 0) +
#   labs(x = "(zentrierte) K√∂rpergr√∂√üe", 
#        y = "")
```




Hat man normalverteilte Variablen, so ist die *Standardabweichung* (engl. standard deviation, SD, $\sigma, s$) eine komfortable Ma√üeinheit der Streuung,
denn damit l√§sst sich die Streuung (Abweichung vom Mittelwert, Residuen) der Normalverteilung gut beschreiben. $\square$



>    [üßë‚Äçüéì]{.content-visible when-format="html"}[\emoji{student}]{.content-visible when-format="pdf"}
 Aber wie berechnet man jetzt diese Standardabweichung?

>    [üßë‚Äçüè´]{.content-visible when-format="html"}[\emoji{teacher}]{.content-visible when-format="pdf"} Moment, noch ein kurzer Exkurs zur Varianz ...

>    [üßë‚Äçüéì]{.content-visible when-format="html"}[\emoji{student}]{.content-visible when-format="pdf"}
 (seufzt)


### Varianz





Die Varianz einer Variable (z.B. Verkaufspreis von Mariokart) ist der mittlere quadrierte Abstand eines Verkaufspreis vom mittleren Verkaufspreis.






:::: {layout="[ 60, 40 ]"}

::: {.column}

@fig-var illustriert die Varianz als "mittlerer Quadratfehler":

1. Man gehe von der H√§ufigkeitsverteilung der Daten aus.
2. Betrachtet man die Daten als Gewichte auf einer Wippe, so ist der Schwerpunkt der Wippe der Mittelwert.
3. Man bilde Quadrate f√ºr jeden Datenpunkt mit der Kantenl√§nge, die dem Abstand des Punktes zum Mittelwert entspricht.
4. Die Quadrate quetscht man jetzt wo n√∂tig in rechteckige Formen (ohne dass sich die Fl√§che √§ndern darf) und verschiebt sie, bis sich alle Formen zu einem Rechteck mit Seitenl√§nge $n$ und $\sigma^2$ anordnen.

:::

::: {.column}


![Varianz [@cmglee_english_2015]](img/Variance_visualisation.svg.png){#fig-var}

:::

::::






@fig-mse visualisiert die Varianz f√ºr @exm-mae.^[Die Abweichungsquadrate wirken optisch nicht quadratisch, 
da die X-Achse breiter skaliert dargestellt ist als die Y-Achse. 
Trotzdem sind es Quadrate, nur nicht optisch, wenn Sie wissen, was ich meine...]
Links sind die *Abweichungsquadrate* dargestellt, rechts die Varianz als "*typisches Abweichungsquadrat*".

:::{.callout-note}
Die Varianz ist also ein Ma√ü, das die typische Abweichung der Beobachtungen  vom Mittelwert in eine Zahl fasst. $\square$
:::


```{r delta-plot, echo = FALSE}
#| echo: false
#| label: fig-mse
#| fig-cap: "Sinnbild zur Varianz als typischer Fehlerbalken"
#| fig-subcap: 
#|   - Quadrierte Fehlerbalken
#|   - "Varianz als 'typischer' Fehlerbalken"
#| warning: false
#| layout-ncol: 2
#| out-width: 100%

library(viridis)

d <-
  tibble(id = 1:4,
         y = c(0.1, -.3, .1, .1)) %>% 
  mutate(y_avg = mean(y),
         delta = y - y_avg,
         delta_abs = abs(delta),
         pos = ifelse(delta > 0, "positiv", "negativ"),
         delta_sq = delta^2)

var_smpl <- mean(d$delta_sq)

p_deltas <- 
d %>%   
  ggplot(aes(x = id, y = y)) +
  geom_hline(yintercept = mean(d$y), linetype = "dashed", show.legend = FALSE) +
  geom_segment(aes(y = mean(d$y),
                   yend = y,
                   x = id,
                   xend = id,
                   linetype = pos), show.legend = FALSE) +
  annotate(geom = "label",
           x = 0,
           hjust = 0,
           y = mean(d$y), 
           label = paste0("MW = ", round(mean(d$y), 2)), show.legend = FALSE) +
  geom_rect(aes(ymin = y_avg,
                ymax = y,
                xmin = id,
                xmax = id+delta_abs),
            fill = "#E69F00FF" ,
            alpha = .5, show.legend = FALSE) +
  geom_text(aes(label=round(delta_sq,3)),
            hjust = "left", 
            nudge_x = 0.05,
            vjust = ifelse(d$pos == "positiv", "top", "bottom"),
            nudge_y = ifelse(d$pos == "positiv", -0.05, 0.05),
            color = "#E69F00FF",
            size = 6, show.legend = FALSE) +
  geom_point(size = 5, show.legend = FALSE) +
  labs(linetype = "",
       x = "",
       y = "")  +
  scale_y_continuous(limits = c(-.3, .1)) +
  scale_x_continuous(limits = c(0, 5)) +
  theme_minimal()

p_var <- 
  d %>%   
    ggplot(aes(x = id, y = y)) + 
    geom_hline(yintercept = mean(d$y), linetype = "dashed") +
     annotate(geom = "label",
             x = 0,
             hjust = 0,
             y = mean(d$y), 
             label = paste0("MW = ", round(mean(d$y), 2))) +
    annotate("rect", 
             xmin =  5, ymin = 0, xmax = 5.2, ymax = var_smpl, 
             fill = "#56B4E9FF") +
    scale_y_continuous(limits = c(-.3, .1)) +
    scale_x_continuous(limits = c(0, 6)) +
    annotate(geom = "label",
                  x = 4,
                  hjust = 0.5,
                  y = -0.1,
                  label = "Varianz",
             color = "#56B4E9FF",
             size = 8) +
  theme_minimal() +
  annotate("label", 
           x = 3, 
           y = -0.2,
           hjust = 0.5,
           label = paste0(var_smpl, " = (0.01+0.01+0.01+0.09)/4"),
           size = 8)

p_deltas
p_var
```








:::{#exm-var}
Sie arbeiten immer noch bei einem Online-Auktionshaus und untersuchen den Verkauf von Videospielen.
Nat√ºrlich mit dem Ziel, dass Ihre Firma mehr von dem Zeug verkaufen kann.
Dazu berechnen Sie die Streuung in den Verkaufspreisen, s. @lst-mario-streu bzw. @tbl-mario-streu. $\square$
:::





```{r}
#| lst-label: lst-mario-streu
#| lst-cap: Berechnung der Streuung des Verkaufpreises als Indikatoren f√ºr die Modellg√ºte des Mittelwerts. 

mariokart_no_extreme <-
  mariokart %>%
  filter(total_pr < 100)  # ohne Extremwerte

m_summ <- 
  mariokart_no_extreme %>% 
  summarise(
    pr_mw = mean(total_pr),
    pr_iqr = IQR(total_pr),
    pr_maa = mean(abs(total_pr - mean(total_pr))),
    pr_var = var(total_pr),
    pr_sd = sd(total_pr))
```



```{r}
#| label: tbl-mario-streu
#| tbl-cap: Kennwerte der Streuung f√ºr den Mariokart-Datensatz
#| echo: false
m_summ
```




Statistiken sind ja sch√∂n ... aber Bilder sind auch gut, s. @fig-var.
Datendiagramme eignen sich gut, 
um (grob) die Streuung einer Variable zu erfassen.


```{r}
#| eval: false
mariokart %>% 
  mariokart_no_extreme %>%   # ohne Extremwerte
  select(total_pr) %>% 
  plot_density()  # oder plot_violin
```



```{r}
#| echo: false
#| fig-cap: "Die Verteilung des Verkaufspreises von Mariokart-Spielen mit MW¬±SD farblich markiert"
#| label: fig-var
#| layout-ncol: 2
#| fig-subcap: 
#|   - Dichtediagramm 
#|   - Violindiagramm
mariokart %>% 
  select(total_pr) %>% 
  filter(total_pr < 100) %>%  # ohne Extremwerte
  ggplot() +
  geom_density(aes(x = total_pr)) +
  geom_rect(data = m_summ, 
               aes(
                 xmin = pr_mw - 0.5*(pr_sd),
                 xmax = pr_mw + 0.5*(pr_sd),
                 ymin = 0,
                 ymax = Inf
               ),
            alpha = .5,
            fill = okabeito_colors()[1]) +
  theme_large_text()

mariokart %>% 
  select(total_pr) %>% 
  filter(total_pr < 100) %>%  # ohne Extremwerte
  ggplot() +
  geom_violin(aes(
    x = 1,
    y = total_pr)) +
  geom_jitter(aes(
    x = 1,
    y = total_pr),
    width = 0.1) +
  scale_x_continuous(limits = c(0, 2)) +
  geom_rect(data = m_summ, 
               aes(
                 ymin = pr_mw - 0.5*(pr_sd),
                 ymax = pr_mw + 0.5*(pr_sd),
                 xmin = -Inf,
                 xmax = Inf
               ),
            alpha = .5,
            fill = okabeito_colors()[1]) +
  theme_large_text()

```




Wer sich die Berechnung von Hand f√ºr `pr_maa` sparen m√∂chte (s. @lst-mario-streu), kann die [Funktion `MeanAD` aus dem Paket `DescTools`](https://rdrr.io/cran/DescTools/man/MeanAD.html) nutzen.





Um die Standardabweichung zu berechnen, berechnet man zun√§chst die *Varianz*, $s^2$ abgek√ºrzt. Hier ist ein "Kochrezept" (Algorithmus) zur Berechnung der Varianz:

1. F√ºr alle Datenpunkte $x_i$: Berechne die Abweichungen vom Mittelwert, $\bar{x}$.
2. Quadriere diese Werte.
3. Summiere dann auf.
4. Teile durch die Anzahl $n$ der Werte.


Als Formel ausgedr√ºckt lautet die Definition der Varianz einer Stichprobe der Gr√∂√üe $n$ wie folgt, s. @eq-var. (Hier geht es um die sog. unkorrigierte Stichprobenvarianz; um anhand einer Stichprobe die Varianz der zugeh√∂rigen Population zu sch√§tzen, teilt man nicht durch $n$, sondern durch $n-1$.)


$${\displaystyle s^{2}:={\frac {1}{n}}\sum _{i=1}^{n}\left(y_{i}-{\bar {y}}\right)^{2}={\frac {1}{n}}\sum _{i=1}^{n}e_i^{2}.}$$ {#eq-var}


:::{#def-var}
### Varianz
Die Varianz ($s^2, \sigma^2$) ist definiert als der Mittelwert der quadrierten Abweichungen (vom Mittelwert), $e_i^2$. $\square$
:::


Die Varianz steht im engen Verh√§ltnis zur Kovarianz, s. @sec-cov.
Die Varianz kann auch verstehen als den *mittleren Quadratfehler* (Mean Squared Error, MSE) eines Modells, s. @eq-mse.



$${\displaystyle MSE:={\frac {1}{n}}\sum _{i=1}^{N}\left(y_{i}-{\hat {y}}\right)^{2}.}$$ {#eq-mse}

Im Fall eines Punktmodells ist der Mittelwert der vorhergesagte Wert eines Modells.



### Die Standardabweichung




:::{#def-sd}
### Standardabweichung
Die Standardabweichung (SD, s, $\sigma$) ist definiert als die Quadratwurzel der Varianz, s. @eq-sd.


$$s := \sqrt{s^2} \square$$ {#eq-sd}

:::

Kennt man die Varianz, so l√§sst sich die Standardabweichung einfach als Quadratwurzel der Varianz berechnen.
Durch das Wurzelziehen besitzt die Standardabweichung wieder *in etwa* die gleiche Gr√∂√üenordnung wie die Daten (im Gegensatz zur Varianz, die durch das Quadrieren sehr gro√ü werden kann).
Aus einem Modellierungsblickwinkel kann man die SD definieren als die Wurzel von MSE.
Dann nennt man sie *Root Mean Squared Error* (RMSE): $RMSE := \sqrt{MSE}$.


:::{.callout-note}
Die SD ist i.d.R. *un*gleich zur MAE, aber (fast) gleich zur RMSE. Entsprechend ist die Varianz (fast) gleich zur MSE. $\square$
:::


:::{#exm-sd-mario}

Sie arbeiten weiter an Ihrem Mariokart-Projekt.
Da Sie heute keine Lust auf viel Tippen haben,
nutzen Sie das R-Paket `easystats` mit der Funktion `describe_distribution`,
s. @tbl-describe-dist1.

```{r}
#| eval: false
library(easystats)

mariokart %>% 
  select(total_pr) %>% 
  describe_distribution()
```

```{r}
#| echo: false
#| tbl-cap: "Ausgabe der Funktion `describe_distribution` (Auszug)"
#| label: tbl-describe-dist1
library(easystats)

mariokart %>% 
  select(total_pr) %>% 
  describe_distribution() |> 
  select(Variable, Mean, SD, IQR, n)
```


>    [üßë‚Äçüéì]{.content-visible when-format="html"}[\emoji{student}]{.content-visible when-format="pdf"} 
Ah! Das war einfach. Reicht auch mal f√ºr heute. $\square$
:::



:::{#exm-gruppen-mw}

Ihr Job als Datenanalyst ist anstrengend, aber auch mitunter interessant. So auch heute. 
Bevor Sie nach Hause gehen, m√∂chten Sie noch eine Sache anschauen.
In einer fr√ºheren Analyse (s. @fig-fehler-red) fanden Sie heraus,
dass die Fehlerbalken k√ºrzer werden, wenn man ein geschickteres und komplexeres Modell findet. 
Das wollen Sie nat√ºrlich pr√ºfen.
Sie √ºberlegen: "Okay, ich will ein einfaches Modell, in dem der Mittelwert das Modell des Verkaufspreis sein soll."

Das spezifizieren Sie so:

```{r}
lm1 <- lm(total_pr ~ 1, data = mariokart)
mae(lm1)  # Modellg√ºte bzw. Modellfehler
```


Im n√§chsten Schritt spezifizieren Sie ein Modell,
in dem der Verkaufpreis eine Funktion der Anzahl der Lenkr√§der ist (√§hnlich wie in @fig-fehler-red):

```{r}
lm2 <- lm(total_pr ~ wheels, data = mariokart)
mae(lm2)
```

Ah! Sehr sch√∂n, Sie haben mit `lm2` ein besseres Modell als einfach nur den Mittelwert gefunden. Ab nach Hause! $\square$
:::


## Streuung als Modellfehler

Wenn wir den Mittelwert als Punktmodell des Verkaufpreises auffassen, so kann man die verschiedenen Kennwerte der Streuung als verschiedene Kennwerte der Modellg√ºte auffassen.

Definieren wir zun√§chst als Punktmodell auf Errisch:

```{r}
lm_mario1 <- lm(total_pr ~ 1, data = mariokart)
```

Zur Erinnerung: Wir modellieren `total_pr` ohne Pr√§diktoren, sondern als Punktmodell,
und zwar sch√§tzen wir den Mittelwert mit den Daten `mariokoart`.

Das (Meta-)Paket `easystats` bietet komfortable Befehle, um die Modellg√ºte zu berechnen:

```{r}
mae(lm_mario1)  # Mean absolute error
mse(lm_mario1)  # Mean squared error
rmse(lm_mario1)  # Root mean squared error
```



## Die z-Transformation

Sie arbeiten immer noch als Datenknecht, Moment, *Datenhecht* bei dem Online-Auktionshaus.
Heute untersuchen Sie die Frage, wie gut sich die Verkaufspreise mit einer einzigen Zahl, dem mittleren Verkaufspreis, beschreiben lassen.
Einige widerspenstige Werte haben Sie dabei einfach des Datensatzes verwiesen.
Schon ist das Leben leichter, s. `mariokart_no_extreme`.

```{r}
mariokart_no_extreme <- 
  mariokart %>% 
  filter(total_pr < 100)
```


```{r}
#| echo: false
mariokart_no_extreme <-
  mariokart_no_extreme %>% 
  mutate(abw = 47.4 - total_pr)
```


@fig-mariokart_no_extreme (links) zeigt, dass es einige Streuung um den Mittelwert herum gibt. @fig-mariokart_no_extreme (rechts) zeigt die (um den Mittelwert) *zentrierten* Daten.

```{r}
#| label: fig-mariokart_no_extreme
#| fig-cap: Verteilung von `mariokart_no_extreme`
#| layout-ncol: 2
#| echo: false
#| fig-subcap:
#|   - "Wie nah dr√§ngen sich die Verkaufspreise um ihren Mittelwert?"
#|   - "Abweichungen vom Mittelwert: zentrierte Daten"


gghistogram(mariokart_no_extreme, x = "total_pr", 
            add = "mean",  # Mittelwert wird hinzugef√ºgt
            add.params = list(color = okabeito_colors()[1], size = 3))  +# Schnickschnack zur Versch√∂nerung
  annotate("label", x=47, y = 5, label = "Mittelwert",
           size = labeltextsize) +
  theme_large_text()

gghistogram(mariokart_no_extreme, x = "abw",
            add = "mean",  # Mittelwert wird hinzugef√ºgt
            add.params = list(color =  okabeito_colors()[1], size = 3))  +# Schnickschnack zur Versch√∂nerung
  annotate("label", x = 0, y = 5, 
           label = "Mittelwert", size = labeltextsize
           ) +
  labs(x = "Abweichung vom Mittelwert") +
  theme_large_text()
```



Tja, das ist doch etwas Streuung um den Mittelwert herum.

:::callout-important
Je weniger Streuung um den Mittelwert (ca. 47 Euro) herum, desto besser eignet sich der Mittelwert als Modell f√ºr die Daten, bzw. desto h√∂her die Modellg√ºte. $\square$
:::

Ja, es ist *etwas* Streuung, aber wie viel? Kann man das genau angeben?
Sie √ºberlegen ... und √ºberlegen. Da! Eine Idee!

Man k√∂nnte vielleicht angeben, wie viel Euro jedes Spiel vom Mittelwert entfernt ist.
Je gr√∂√üer diese Abweichung, desto schlechter die Modellg√ºte!
Also rechnen Sie diese Abweichung aus, @lst-zentrieren.

```{r}
#| lst-label: lst-zentrieren
#| lst-cap: Zentrieren einer Variablen
mariokart_no_extreme <-
  mariokart_no_extreme %>% 
  mutate(abw = 47.4 - total_pr)
```

Anders gesagt: Wir haben die Verkaufspreise *zentriert.*

:::{#def-zentrieren}
### Zentrieren
Zentrieren bedeutet, von jedem Wert einer Verteilung $X$ den Mittelwert abzuziehen.
Daher ist der neue Mittelwert (der zentrierten Verteilung) gleich Null. $\square$
:::




Aber irgendwie sind Sie noch nicht am Ziel Ihrer √úberlegungen:
Woher wei√ü man, ob 10 Euro oder 20 Euro "viel" Abweichung vom Verkaufspreis ist?
Man m√ºsste die Abweichung eines Verkaufpreis zu irgendetwas in Bezug setzen.
Wieder! Ein Geistesblitz!
Man k√∂nnte doch die jeweilige Abweichung  in Bezug setzen zur *mittleren (absoluten) Abweichung* (MAA)!
Ein alternativer,
√§hnlicher Kennwert zur mittlerer absolute Abweichung ist die SD.
Sie haben geh√∂rt, dass die SD gebr√§uchlicher ist als die MAA. 
Um sich als Checker zu pr√§sentieren, berechnen Sie also auch die SD; die beiden Koeffizienten sind ja √§hnlich.

Also: Wenn ein Spiel 10 Euro vom Mittelwert abweicht und die SD 10 Euro betragen sollte,
dann h√§tten wir eine "standardisierte" (abgek√ºrzt manchmal mit `std`) Abweichung von 1, weil 10/10=1.
Begeistert √ºber Ihre Geistesblitze machen Sie sich ans Werk.

```{r}
mariokart_no_extreme <-
  mariokart_no_extreme %>% 
  mutate(abw_std = abw / sd(abw),  # std wie "standardisiert"
         abw_std2 = abw / mean(abs(abw)))  
```

Zufrieden betrachten Sie Ihr Werk, s. @fig-z-transf. 
In @fig-z-transf sieht man oben die Rohwerte und unten die transformierten Werte,
die wir hier als *z-standardisiert* bezeichnen, 
da wir sie in Bezug zur "typischen Abweichung", der SD, gesetzt haben.

```{r}
#| warning: false
#| echo: false
#| label: fig-z-transf
#| fig-width: 8
#| fig-aspect: 0.8
#| out-width: "100%"
#| fig-cap: "Standardisierung von Abweichungswerten bzw. einer Verteilung; der vertikale Balken zeigt den Mittelwert"

p1 <- gghistogram(mariokart_no_extreme, x = "abw",
            add = "mean",  # Mittelwert wird hinzugef√ºgt
            add.params = list(color = okabeito_colors()[1], size = 3)) +
  labs(title = "Zentrierte Werte") +
  annotate("label", x = 0, y = 25, label = "MW", vjust = 1) +
  labs(x = "Abweichung vom Mittelwert") 
  

p2 <-  gghistogram(mariokart_no_extreme, x = "abw_std",
            add = "mean",  # Mittelwert wird hinzugef√ºgt
            add.params = list(color = okabeito_colors()[1], size = 3)) +
  labs(title = "z-Standardisierte Werte") +
  annotate("label", x = 0, y = 25, label = "MW", vjust = 1)  +
  labs(x = "z-standardisierte Abweichung vom Mittelwert")

arrow_down <- png::readPNG("img/arrow-down.png", native = TRUE)
p_ad <- ggplot() + inset_element(arrow_down, 0, 0, 1, 1)

plots(p1, p_ad, p2, n_rows = 3)
```


Wir fassen die Schritte unserer Umrechnung ("Transformation") zusammen wie in einem Kochrezept:

1. Nimm die Verteilung der Verkaufspreise
2. Berechne die Abweichungen vom mittleren Verkaufspreis (Differenz Mittelwert und jeweiliger Verkaufspreis)
4. Teile die Abweichungen (Schritt 2) durch die SD


Diese Art von Transformation bezeichnet man als
*z-Transformation* und die resultierenden Werte als *z-Werte*.

:::{#def-z-werte}
### z-Werte
z-Werte sind das Resultat der z-Transformation.
F√ºr die Variable $X$ berechnet sich der 
z-Wert der $i$-ten Beobachtung so: $z_i := \frac{x_i - \bar{x}}{sd_x}.\;\square$
:::

z-Werte sind n√ºtzlich, weil sie die "relative" Abweichung
einzelner Beobachtungen vom Mittelwert anzeigen.
Nach einer *Faustregel* spricht man von extremen Abweichungen
(Extremwerten, Ausrei√üern), wenn $z_i \ge 2.5$ [@shimizu2022].


## Fazit

Der "gesunde Menschenverstand" w√ºrde spontan den mittleren Absolutabstand (MAA oder MAE) 
der Varianz (oder der Standardabweichung, SD) vorziehen. 
Das ist vern√ºnftig, 
denn die MAA ist anschaulicher und damit n√ºtzlicher als die Varianz und die SD.
Warum sollte man √ºberhaupt ein unanschauliches Ma√ü wie die Varianz verwenden? 
Wenn es nur um deskriptive Statistik geht, braucht man die Varianz (oder die SD) nicht unbedingt.
Gr√ºnde, warum Sie die Varianz (bzw. SD) kennen und nutzen sollten, sind:

- Die SD ist n√ºtzlich zur Beschreibung der Normalverteilung.
- Die Varianz wird h√§ufig verwendet bzw. in Forschungsarbeiten berichtet, also m√ºssen Sie die Varianz kennen.


Liegen Extremwerte vor, kann es vorteilhafter sein, 
den IQR vorzuziehen gegen√ºber Mittelwert basierten Streuungsma√üen (MAA, Varianz, SD).


## Aufgaben



Die Webseite [datenwerk.netlify.app](https://datenwerk.netlify.app) stellt eine Reihe von einschl√§gigen √úbungsaufgaben bereit. Sie k√∂nnen die Suchfunktion der Webseite nutzen, um die Aufgaben mit den folgenden Namen zu suchen:

- [mariokart-sd2](https://sebastiansauer.github.io/Datenwerk/posts/mariokart-sd2/mariokart-sd2)
- [mariokart-sd3](https://sebastiansauer.github.io/Datenwerk/posts/mariokart-sd3/mariokart-sd3)
- [Kennwert-robust](https://sebastiansauer.github.io/Datenwerk/posts/kennwert-robust/kennwert-robust)
- [summarise04](https://sebastiansauer.github.io/Datenwerk/posts/summarise04/summarise04)
- [summarise05](https://sebastiansauer.github.io/Datenwerk/posts/summarise05/summarise05) 
- [vis-mariokart-variab](https://sebastiansauer.github.io/Datenwerk/posts/vis-mariokart-variab/vis-mariokart-variab)
- [sd-vergleich](https://sebastiansauer.github.io/Datenwerk/posts/sd-vergleich/sd-vergleich)
- [nasa01](https://sebastiansauer.github.io/Datenwerk/posts/nasa01/nasa01)
- [Streuung-Histogramm](https://sebastiansauer.github.io/Datenwerk/posts/streuung-histogramm/streuung-histogramm)
- [mariokart-sd1](https://sebastiansauer.github.io/Datenwerk/posts/mariokart-sd1/mariokart-sd1)
- [summarise06](https://sebastiansauer.github.io/Datenwerk/posts/summarise06/summarise06)
- [mariokart-desk01](https://sebastiansauer.github.io/Datenwerk/posts/mariokart-desk01/mariokart-desk01)

::::::: {.content-visible when-format="html" unless-format="epub"}



:::::{#exr-handy}
### Analysieren Sie den Datensatz zur Handynutzung





:::: {layout="[ 80, 20 ]"}
::: {#first-column}
Die Forschungsfrage [einer Studie](https://docs.google.com/forms/d/e/1FAIpQLSfM6oDLHX4_lqWq-bXw39drTkdGAvecE6ow2HIKoxdrVygp2A/viewform) fragt, ob Handynutzung die Konzentrationsf√§higkeit verringert. 
Nehmen Sie ggf. an der Studie (Umfrage) teil (sie ist anonym und dauert drei Minuten).
:::

::: {#second-column}

```{r}
#| echo: false
#| out-width: "75%"
#| fig-align: center
qr <- qrcode::qr_code("https://docs.google.com/forms/d/e/1FAIpQLSfM6oDLHX4_lqWq-bXw39drTkdGAvecE6ow2HIKoxdrVygp2A/viewform")
plot(qr)
```
:::
::::






 
Laden Sie den [Datensatz zur Handynutzung](https://docs.google.com/spreadsheets/d/1SWMj4rIIIJdAsfsSKQHSg8jHr_OuKLpJx_0XV4LGnH0/edit?usp=sharing) von Google-Docs herunter.^[<https://docs.google.com/spreadsheets/d/1SWMj4rIIIJdAsfsSKQHSg8jHr_OuKLpJx_0XV4LGnH0/edit?usp=sharing>] 
Berechnen Sie dann g√§ngige deskriptive Statistiken und visualisieren Sie sie. $\square$

**L√∂sung: Daten importieren**

Sie k√∂nnen die Daten entweder selber herunterladen oder aber die folgende Version des Datensatzes verwenden.
In beiden F√§llen ist es n√ºtzlich, den (absoluten oder relativen) Pfad anzugeben:

::: {.content-visible when-format="html"}

```{r}
data_path <- "https://raw.githubusercontent.com/sebastiansauer/statistik1/main/data/Smartphone-Nutzung%20(Responses)%20-%20Form%20responses%201.csv"
```
:::


<!-- ::: {.content-visible when-format="pdf"} -->

<!-- ```{r} -->
<!-- data_path <- paste0( -->
<!--   "https://raw.githubusercontent.com/sebastiansauer/", -->
<!--   "statistik1/main/data/Smartphone-Nutzung%20", -->
<!--   "(Responses)%20-%20Form%20responses%201.csv") -->
<!-- ``` -->
<!-- ::: -->

Dann k√∂nnen Sie die Daten wie gewohnt importieren:

```{r}
smartphone_raw <- read.csv(data_path)
```

**L√∂sung: Daten aufbereiten**

Die Spaltennamen sind sehr unsch√∂n. Lassen Sie uns daher die Spaltennamen umbenennen (aber vorab sichern):

```{r}
item_labels <- names(smartphone_raw)

names(smartphone_raw) <- paste0("item",1:ncol(smartphone_raw))
```


Check:

```{r}
glimpse(smartphone_raw)
```




### Komplette L√∂sung

üòÅ



:::::



### Fallstudie zur Lebenszufriedenheit

Die OECD f√ºhrt eine [weltweite Studie zur Lebenszufriedenheit](https://www.oecd.org/wise/measuring-well-being-and-progress.htm) durch.^[<https://www.oecd.org/wise/measuring-well-being-and-progress.htm>]
Arbeiten Sie die die [Fallstudie "oecd-yacsda" im Datenwerk](https://sebastiansauer.github.io/Datenwerk/posts/oecd-yacsda/) durch, 
um ein tieferes Verst√§ndnis f√ºr die Lebenszufriedenheit in verschiedenen L√§ndern der Welt zu bekommen. 

:::::::



## Literaturhinweise


Allen Downey [-@downey_probably_2023] stellt in seinem vergn√ºglich zu lesenden Buch eine kurzweilige Einf√ºhrung in die Statistik vor;
auch Streuungsma√üe haben dabei einen Auftritt.
Wer mehr "Lehrbuch-Feeling" sucht, wird bei @cetinkaya-rundel_introduction_2021 f√ºndig 
(das Buch ist online frei verf√ºgbar).
Es ist kein Geheimnis, dass Streuungsma√üe keine ganz neuen Themen in der Statistik sind. Aber hey, Oldie is Goldie, ohne Streuungsma√üe geht's nicht.
Jedenfalls werden Sie in jedem Statistik-Lehrbuch,
dass Sie in der Bib (oder sonst wo) aus dem Regal ziehen, 
f√ºndig werden zu diesem Thema.
Die B√ºcher unterscheiden sich meist "nur" in ihrem Anspruch bzw. der didaktischen Aufmachung; 
f√ºr alle ist da was dabei.



